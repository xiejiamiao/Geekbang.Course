---
title: gRPC in ASP.NET Core
date: 2020/04/20 18:30:00
tag:
- gRPC
- ASP.NET Core
categories:
- ASP.NET Core
keywords:
- .NET Core
- ASP.NET Core
- gRPC
---

- [开发环境](#%e5%bc%80%e5%8f%91%e7%8e%af%e5%a2%83)
  - [VSCode](#vscode)
- [消息类型的演进](#%e6%b6%88%e6%81%af%e7%b1%bb%e5%9e%8b%e7%9a%84%e6%bc%94%e8%bf%9b)
  - [更新消息类型的规则](#%e6%9b%b4%e6%96%b0%e6%b6%88%e6%81%af%e7%b1%bb%e5%9e%8b%e7%9a%84%e8%a7%84%e5%88%99)
  - [默认值](#%e9%bb%98%e8%ae%a4%e5%80%bc)
  - [枚举](#%e6%9e%9a%e4%b8%be)
- [编写`proto`文件](#%e7%bc%96%e5%86%99proto%e6%96%87%e4%bb%b6)
- [在`.NET Core`中使用`gRPC`](#%e5%9c%a8net-core%e4%b8%ad%e4%bd%bf%e7%94%a8grpc)
  - [`ASP.NET Core`](#aspnet-core)
  - [`.NET Core`](#net-core)
  - [引包之后的操作](#%e5%bc%95%e5%8c%85%e4%b9%8b%e5%90%8e%e7%9a%84%e6%93%8d%e4%bd%9c)
  - [作为服务端](#%e4%bd%9c%e4%b8%ba%e6%9c%8d%e5%8a%a1%e7%ab%af)
  - [作为客户端](#%e4%bd%9c%e4%b8%ba%e5%ae%a2%e6%88%b7%e7%ab%af)

# 开发环境
## VSCode
window下需要安装`Clang`，百度找`Clang`，去官网自行下载，如果下载速度慢，可以添加以下内容到`C:\Windows\System32\drivers\etc\host`文件
```
54.231.82.146 vagrantcloud-files-production.s3.amazonaws.com
219.76.4.4 s3.amazonaws.com
219.76.4.4 github-cloud.s3.amazonaws.com
```
然后再`VSCode`中安装两个插件
```
vscode-proto3
Clang-Format
```

# 消息类型的演进
* 向前兼容变更：使用新的`.proto`文件来写数据 -- 从旧的`.proto`文件读取数据
* 向后兼容变更：使用旧的`.proto`文件来写数据 -- 从新的`.proto`文件读取数据
## 更新消息类型的规则
* 不要修改任何现有字段的数字(tag)
* 可以添加新的字段，旧的代码会忽略掉新字段的解析，所以要注意新字段的默认值
* 字段可以被删除，只要它们的数字`(tag)`在更新后的消息类型中不再使用即可，也可以把字段名使用`OBSOLETE_`前缀而不是删除字段，或者把这些字段的数字`(tag)`进行保留`(reserved)`，以免未来其他开发者不小心使用这些字段
* 尽量不要修改原有的字符数据类型
## 默认值
默认值在更新`Protocol Buffer`消息定义的时候有很重要的作用，它可以防止对现有代码/新代码造成破坏性影响。它们也可以保证字段永远不会有`null`值

但是，默认值还是非常危险的：**你无法区分这个默认值到底是来自一个丢失的字段还是字段的实际值正好等于默认值**

所以，需要保证这个默认值对于业务来说是一个毫无意义的值，例如`int32 pop`人口这个字段的默认值可以设置为`-1`，再就是可能需要再代码里对默认值进行判断处理

## 枚举
`enum`同样可以进化，就和消息的字段一样，可以添加、删除值，也可以保留值

但是如果代码不知道它接收到的值对应哪个`enum`值，那么`enum`的默认值将会被采用

# 编写`proto`文件


# 在`.NET Core`中使用`gRPC`
## `ASP.NET Core`
依赖包：
```
Grpc.AspNetCore
```

## `.NET Core`
依赖包：
```
Google.Protobuf
Grpc.Net.Client
Grpc.Tools
```

## 引包之后的操作
按照项目类型引入上面的包之后，直接编译是不会得到`gRPC`框架生成的代码，需要做以下操作：
右键.proto文件 -> 属性 -> 将`Build Action`选择为`Protobuf compiler` -> `gRPC Stub Classes`按照需求选择`Client and Server/Client only/Server only/Do not generate`

进行完上面的操作之后，编译项目会在`obj\Debug\netcoreapp3.1`目录里自动生成`RPC`代码

## 作为服务端
怎么实现`rpc`定义的方法：假设在`.proto`文件里有`EmployeeService`这样一个`service`，在编译项目之后，会有一个`EmployeeService.EmployeeServiceBase`的类，自己编写一个类继承自`EmployeeService.EmployeeServiceBase`这个类，然后`override`去重载`.proto`服务里定义的那些`rpc`方法即可

## 作为客户端
怎么调用`rpc`定义的方法：需要先创建`Channel`，例如：
``` csharp
using var channel = GrpcChannel.ForAddress("https://localhost:5001");
```
然后假设在`.proto`文件里有`EmployeeService`这样一个`service`，在编译项目之后(需要选择client或client and server)，会有一个`EmployeeService.EmployeeServiceClient`的类，实例化这个类就相当实例化一个`client`，例如：
``` csharp
var client = new EmployeeService.EmployeeServiceClient(channel);
```
在`client`里就可以调用`.proto`服务里定义的那些方法
